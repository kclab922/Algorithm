# 풀이과정
# 전체구조: moves에 적힌 세로줄로 가서, 맨 위 칸부터 인형 유무를 하나씩 검색
#          => 인형이 있으면 바구니로 보내고, 걔랑 원래 바구니 맨 위 애랑 같으면 터뜨리기
#          => 해당 세로줄의 나머지 칸은 더 볼 필요 없으므로 검색 멈추기
# 1문단: 터트린 인형의 개수: count / 잡힌 인형을 넣는 바구니: basket 으로 설정
# 2문단: board라는 이차원 배열에 접근하는 인덱스로 아래 지표를 활용
#       moves는 세로줄 단위로 이동하므로, 어느 '열'을 검색해야 하는지 알려주는 지표 => '열'을 표현하는 인덱스로 활용
#       board의 길이 = board의 원소 개수 = 행의 개수 => '행'을 표현하는 인덱스로 활용
#       해당 위치의 숫자가 0이 아니면 = 숫자가 있으면 = 인형이 있으면
#       바구니에 해당 숫자를 넣고
#       board의 해당 위치는 0으로 바꿔줌 (나중에 검색하다 같은 칸을 다시 볼 수 있는데, 이때 인형이 있으면 안되므로)
# 3문단: 바구니 속 원소가 2개 이상이고 + 맨 뒤와 그 앞이 같으면 pop 2번 
#       한 번 터질 때 터지는 인형의 개수는 2개이므로 +2

def solution(board, moves):
    count = 0
    basket = []

    for m in moves:
        for i in range(len(board)):
            if board[i][m-1] != 0:
                basket += [board[i][m-1]]
                board[i][m-1] = 0

                if len(basket) >= 2 and basket[-1] == basket[-2] :
                    basket.pop()
                    basket.pop()
                    count += 2

                break

    return count

print(solution([[0,0,0,0,0],[0,0,1,0,3],[0,2,5,0,1],[4,2,4,4,2],[3,5,1,3,1]], [1,5,3,5,1,2,1,4]))